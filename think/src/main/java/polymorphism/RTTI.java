package polymorphism;


// DownCasting & Runtime type information (RTTI).
// {ThrowsException}
class Useful {
    public void f() {
    }

    public void g() {
    }
}

class MoreUseful extends Useful {

    @Override
    public void f() {
    }

    @Override
    public void g() {
    }

    public void u() {
    }

    public void v() {
    }

    public void w() {
    }
}


/**
 * 由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，所以我们
 * 就想，通过向下转型一也就是在继承层次中向下移动一应该能够获取类型信
 * 息。
 * <p>
 * 然而，我们知道向上转型是安全的，因为基类不会具有大于导出类的接囗。
 * <p>
 * 因此，我们通过基类接囗发送的消息保证都能被接受。但是对于向下转型，
 * <p>
 * 例如，我们无法知道一个"几何形状"它确实就是一个"圆"，它可以是一个三角形、
 * 正方形或其他一些类型。
 * <p>
 * 要解决这个问题，必须有某种方法来确保向下转型的正确性，使我们不至于
 * 贸然转型到一种错误类型，进而发出该对象无法接受的消息。
 * 这样做是极其不安全的。
 * <p>
 * 在某些程序设计语言（如C++)中，我们必须执行一个特殊的操作来获得安全的向下转型。
 * 但是在Java语言中，所有转型都会得到检查！
 * <p>
 * 所以即使我们只是进行一次普通的加括弧形式的类型转换，在进入运行期时仍然会对其进行检查，
 * 以便保证它的确是我们希望的那种类型。
 * <p>
 * 如果不是，就会返回一个ClassCastException（类转型异常）。
 * <p>
 * 这种在运行期间对类型进行检查的行为称作"运行时类型识别"(RTTI)。
 * <p>
 * 下面的例子说明RTTI的行为：
 * <p>
 * ****** 识别结果 1******
 * <p>
 * 正如前一个示意图中所示，MoreUseful（更有用的）接囗扩展了Useful（有
 * 用的）接囗；
 * <p>
 * 但是由于它是继承而来的，所以它也可以向上转型到Useful类型。
 * <p>
 * 我们在main()方法中对数组x进行初始化时可以看到这种情况的发生。
 * <p>
 * 既然数组中的两个对象都属于Useful类型，所以我们可以调用f()和g()这两个方法。
 * <p>
 * 如果我们试图调用u()方法（它只存在于MoreUseful)，就会返回一条编译时出错消息。
 * <p>
 * 如果想访问MoreUseful对象的扩展接囗，就可以尝试进行向下转型。
 * <p>
 * 如果所转类型是正确的类型，那么转型成功；
 * <p>
 * 否则，就会返回一个ClassCastException异常。
 * <p>
 * 我们不必为这个异常编写任何特殊的代码，因为它指出的是程序员在程序
 * 中任何地方都可能会犯的错误。
 * <p>
 * {Throws-Exception}注释标签告知本书的构建系统：在运行该程序时，预期抛出一个异常。
 * RTTI的内容不仅仅包括转型处理。
 * <p>
 * 例如它还提供一种方法，使你可以在试图向下转型之前，查看你所要处理的类型。
 * 第14章专门讨论Java运行时类型识别的所有不同方面。
 * <p>
 * <p>
 * 多态意味着"不同的形式"。
 * <p>
 * 在面向对象的程序设计中，我们持有从基类继承而来的相同接囗，以及使用该接囗的不同形式：
 * 不同版本的动态绑定方法。
 * <p>
 * 在本章中我们已经知道，如果不运用数据抽象和继承，就不可能理解或者甚至不可能创建多态的例子。
 * <p>
 * 多态是一种不能单独来看待的特性（例如，像switch语句是可以的），
 * 相反它只能作为类关系"全景"中的一部分，与其他特性协同工作。
 * <p>
 * 为了在自己的程序中有效地运用多态乃至面向对象的技术，必须扩展自己的
 * 编程视野，使其不仅包括个别类的成员和消息，而且还要包括类与类之间的共同
 * 特性以及它们之间的关系。
 * <p>
 * 尽管这需要极大的努力，但是这样做是非常值得的，因为它可以带来很多成效：
 * <p>
 * 更快的程序开发过程、更好的代码组织、更好扩展的程序以及更容易的代码维护等。
 */
public class RTTI {
    public static void main(String[] args) {
        Useful[] x = {
                new Useful(),
                new MoreUseful()
        };
        x[0].f();
        x[1].g();
        // Compile time: method not found in Useful:
        //! x[1].u();
        ((MoreUseful) x[1]).u(); // Downcast/RTTI
        ((MoreUseful) x[0]).u(); // Exception thrown
    }
}
