package reusing;

// Making an entire class final.
class SmallBrain {
}

final class Dinosaur {
    int i = 7;
    int j = 1;
    SmallBrain x = new SmallBrain();

    void f() {
    }

    public int getI() {
        return i;
    }

    public int getJ() {
        return j;
    }
}

//! class Further extends Dinosaur {}
// error: Cannot extend final class 'Dinosaur'


/**
 * 在设计类时，将方法指明是final的，应该说是明智的。
 * 你可能会觉得，没人会想要覆盖你的方法。
 * 有时这是对的。但请留意你所作的假设。
 * <p>
 * 要预见类是如何被复用的一般是很困难的，特别是对于一个通用类而言更是如此。
 * <p>
 * 如果将一个方法指定为final，可能会妨碍其他程序员在项目中通过继承来复用你的类，
 * 而这只是因为你没有想到它会以那种方式被运用。
 * <p>
 * Java标准程序库就是一个很好的例子。
 * 特别是Java1.0/1.1中Vector类被广泛地运用，而且从效率考虑（这近乎是一个幻想），
 * 如果所有的方法均未被指定为final的话，它可能会更加有用。
 * <p>
 * 很容易想像到，人们可能会想要继承并覆盖如此基础而有用的类，
 * 但是设计者却认为这样做不太合适。
 * 这里有两个令人意外的原因。
 * <p>
 * 第一，Stack继承自Vector，就是说Stack是个Vector，这从逻辑的观点看是不正确的。
 * <p>
 * 尽管如此，Java的设计者们自己仍旧继承了Vector在以这种方式创
 * 建Stack时，他们应该意识到final方法显得过于严苛了。
 * <p>
 * 第二，Vector的许多最重要的方法一如addElement()和elementAt()是同步的。
 * <p>
 * 正如在第21章中将要看到的那样，这将导致很大的执行开销，可能会抹
 * 煞final所带来的好处。
 * <p>
 * 这种情况增强了人们关于程序员无法正确猜测优化应当发生于何处的观点。
 * <p>
 * 如此蹩脚的设计，却要置于我们每个人都得使用的标准程序库中，这是很糟糕的
 * （幸运的是，现代Java的容器库用ArrayList代了Vector.
 * ArrayList的行为要合理得多。遗憾的是仍然存在用旧容器库编写新程序代码的情况）。
 * <p>
 * 留心一下Hashtable，这个例子同样有趣，它也是一个重要的Java1.0/1.1标准
 * 库类，而且不含任何final方法。
 * <p>
 * 如本书其他地方所提到的，某些类明显是由一些互不相关的人设计的
 * （读者会发现，名为Hashtable的方法相对于Vector中的方法要简洁得多，这又是一个证据）。
 * <p>
 * 对于类库的使用者来说，这又是一个本不该如此轻率的事物。
 * <p>
 * 这种不规则的情况只能使用户付出更多的努力。这是对粗糙的设
 * 计和代码的又一讽刺（请注意，现代Java的容器库用HashMap代替了Hashtable)
 * <p>
 * <p>
 * <p>
 * 继承和组合都能从现有类型生成新类型。
 * <p>
 * 组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接囗。
 * <p>
 * 在使用继承时，由于导出类具有基类接囗，因此它可以向上转型至基类，
 * 这对多态来讲至关重要，就像我们将在下一章中将要看到的那样。
 * <p>
 * 尽管面向对象编程对继承极力强调，但在开始一个设计时，一般应优先选择
 * 使用组合（或者可能是代理），只在确实必要时才使用继承。
 * <p>
 * 因为组合更具灵活性。
 * 此外，通过对成员类型使用继承技术的添加技巧，可以在运行时改变那些成员对象的类型和行为。
 * <p>
 * 因此，可以在运行时改变组合而成的对象的行为。
 * 在设计一个系统时，目标应该是找到或创建某些类，其中每个类都有具体的用途，
 * 而且既不会太大（包含太多的功能而难以复用），也不会太小（不添加其他功能就无法使用）。
 * <p>
 * <p>
 * 如果你的设计变得过于复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常会有所帮助。
 * <p>
 * 当你开始设计一个系统时，应该认识到程序开发是一种增量过程，犹如人类的学习一样，这一点很重要。
 * <p>
 * 程序开发依赖于实验，你可以尽己所能去分析，但当你开始执行一个项目时，你仍然无法知道所有的答案。
 * <p>
 * 如果将项目视作是一种有机的、进化着的生命体而去培养，而不是打算像盖摩天大楼一样快速见效，
 * 就会获得更多的成功和更迅速的回馈。
 * <p>
 * 继承与组合正是在面向对象程序设计中使得你可以执行这种实验的最基本的两个工具。
 */
public class Jurassic {
    public static void main(String[] args) {
        Dinosaur n = new Dinosaur();
        n.f();
        n.i = 40;
        n.j++;
        System.out.println("i:" + n.getI());
        System.out.println("j:" + n.getJ());
    }
}
