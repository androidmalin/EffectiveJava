package reusing;

// Inheritance & upCasting.
class Instrument {
    public void play() {
    }

    static void tune(Instrument i) {
        // ...
        i.play();
    }
}

// Wind objects are instruments
// because they have the same interface:
public class Wind extends Instrument {

    /**
     * 7.7 向上转型
     * <p>
     * "为新的类提供方法"并不是继承技术中最重要的方面，其最重要的方面是用
     * 来表现新类和基类之间的关系。
     * <p>
     * 这种关系可以用"新类是现有类的一种类型"这句话加以概括。
     * <p>
     * 这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。
     * <p>
     * 例如，假设有一个称为Instrument的代表乐器的基类和一个称为Wind的导出类。
     * <p>
     * 由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发
     * 送的所有信息同样也可以向导出类发送。
     * <p>
     * 如果Instrument类具有一个play()方法，那么Wind乐器也将同样具备。
     * <p>
     * 这意味着我们可以准确地说Wind对象也是一种类型的Instrument
     * <p>
     * 下面这个例子说明了编译器是怎样支持这一概念的：
     * <p>
     * <p>
     * 在此例中，tune()方法可以接受Instrument引用，这实在太有趣了。
     * <p>
     * 但在Wind.main()中，传递给tune0()法的是一个Wind引用。
     * <p>
     * 鉴于Java对类型的检查十分严格，
     * 接受某种类型的方法同样可以接受另外一种类型就会显得很奇怪，
     * <p>
     * 除非你认识到Wind对象同样也是一种Instrument对象，
     * <p>
     * 在tune()中，程序代码可以对Instrument和它所有的导出类起作用，
     * <p>
     * 这种将Wind引用转换为Instrument引用的动作，我们称之为向上转型。
     * <p>
     * <p>
     * <p>
     * <p>
     * 7.7.1为什么称为向上转型
     * <p>
     * 该术语的使用有其历史原因，并且是以传统的类继承图的绘制方法为基础的：
     * <p>
     * 将根置于页面的顶端，然后逐渐向下。（当然也可以以任何你认为有效的方法进行绘制。）
     * 于是，Wind.java的继承图就是（如下图所示）.
     * <p>
     * Instrument
     * ^
     * |
     * Wind
     *
     * <p>
     * 由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。
     * <p>
     * 由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。
     * 也就是说，导出类是基类的一个超集。
     * <p>
     * 它可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。
     * <p>
     * 在向上转型的过程中，类接囗中唯一可能发生的事情是丢失方法，而不是获取它们。
     * <p>
     * 这就是为什么编译器在"未曾明确表示转型"或"未曾指定特殊标记"的情况下，仍然允许向上转型的原因。
     * <p>
     * <p>
     * <p>
     * <p>
     * 7.7.2再论组合与继承
     * <p>
     * 在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数
     * 据和方法包装进一个类中，并使用该类的对象。
     * <p>
     * 也可以运用组合技术使用现有类来开发新的类；而继承技术其实是不太常用的。
     * <p>
     * 因此，尽管在教授OOP的过程中我们多次强调继承，但这并不意味着要尽可能使用它。
     * <p>
     * 相反，应当慎用这一技术，其使用场合仅限于你确信使用该技术确实有效的情况。
     * <p>
     * 到底是该用组合还是用继承，
     * 一个最清晰的判断办法就是问一问自己是否需要从新类向基类进行向上转型。
     * <p>
     * 如果必须向上转型，则继承是必要的；但如果不需要，则应当好好考虑自己是否需要继承。
     * <p>
     * 第8章提出了一个使用向上转型的最具说服力的理由，但只要记得自问一下"我真的需要向上转型吗？"
     * 就能较好地在这两种技术中做出决定。
     * <p>
     * <p>
     * 重点关注
     */
    public static void main(String[] args) {
        Wind flute = new Wind();
        Instrument.tune(flute); // UpCasting
    }
}
