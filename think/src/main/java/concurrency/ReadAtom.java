package concurrency;

public class ReadAtom {

    /**
     * 在有关Java线程的讨论中，一个常不正确的知识是"原子操作不需要进行同步控制"。
     * <p>
     * 原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定
     * 可以在可能发生的"上下文切换"之前（切换到其他线程执行）执行完毕。
     * <p>
     * 依赖于原子性是很棘手且很危险的，如果你是一个并发专家，或者你得到了来自这样的
     * 专家的帮助，你才应该使用原子性来代替同步。
     * <p>
     * 如果你认为自己足够聪明可以应付这种玩火似的情况，那么请接受下面的测试：
     * Goetz测试：如果你可以编写用于现代微处理器的高性能JVM，那么就有资
     * 格去考虑是否可以避免同步。
     * <p>
     * 了解原子性是很有用的，并且要知道原子性与其他高级技术一道，在
     * java.util.concurrent类库中已经实现了某些更加巧妙的构件。
     * <p>
     * 但是要坚决抵挡住完全依赖自己的能力去进行处理的这种欲望，
     * 请看看之前表述的Brian的同步规则。
     * 原子性可以应用于除long和double之外的所有基本类型之上的"简单操作"。
     * <p>
     * <p>
     * 对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证它们
     * 会被当作不可分（原子）的操作来操作内存。
     * <p>
     * 但是JVM可以将64位(long和double变量）的读取和写入当作两个分离的32位操作来执行，
     * 这就产生了在一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果
     * 的可能性（这有时被称为字撕裂，因为你可能会看到部分被修改过的数值）。
     * <p>
     * 但是，当你定义long或double变量时，如果使用volatile关键字，就会获得（简单的
     * 赋值与返回操作的）原子性（注意，在JavaSE5之前，volatile一直未能正确地工作）。
     * <p>
     * 不同的JVM可以任意地提供更强的保证，但是你不应该依赖于平台相关的特性。
     * <p>
     * 因此，原子操作可由线程机制来保证其不可中断，专家级的程序员可以利用
     * 这一点来编写无锁的代码，这些代码不需要被同步。
     * <p>
     * 但是即便是这样，它也是一种过于简化的机制。
     * <p>
     * 有时，甚至看起来应该是安全的原子操作，实际上也可能不安全。
     * <p>
     * 本书的读者通常不能通过前面提及的Goetz测试，因此也就不具备用原子操
     * 作来替换同步的能力。
     * <p>
     * 尝试着移除同步通常是一种表示不成熟优化的信号，并且将会给你招致大量的麻烦，
     * <p>
     * 而你却可能没有收获多少好处，甚至压根没有任何好处。
     * <p>
     * 在多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个
     * CPU)上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。
     * <p>
     * 任务做出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不
     * 可视的（例如，修改只是暂时性地存储在本地处理器的缓存中），因此不同的任
     * 务对应用的状态有不同的视图。
     * <p>
     * 另一方面，同步机制强制在处理器系统中，一个
     * 任务做出的修改必须在应用中是可视的。如果没有同步机制，那么修改时可视将无法确定。
     * <p>
     * volatile关键字还确保了应用中的可视性。
     * <p>
     * 如果你将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。
     * 即便使用了本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就发生在主存中。
     * <p>
     * 理解原子性和易变性是不同的概念这一点很重要。在非volatile域上的原子操
     * 作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。
     * <p>
     * 如果多个任务在同时访问某个域，那么这个域就应该是volatile的，
     * 否则，这个域就应该只能经由同步来访问。
     * <p>
     * 同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。
     * 一个任务所作的任何写入操作对这个任务来说都是可视的，因此如果它只需
     * 要在这个任务内部可视，那么你就不需要将其设置为volatile的。
     */
    public static void main(String[] args) {

    }
}
