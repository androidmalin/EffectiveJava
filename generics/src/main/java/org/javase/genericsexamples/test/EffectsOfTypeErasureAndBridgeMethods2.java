package org.javase.genericsexamples.test;

public class EffectsOfTypeErasureAndBridgeMethods2 {


    //After type erasure, the Node and MyNode classes become:
    public static class Node {
        public Object data;

        public Node(Object data) {
            this.data = data;
        }

        public void setData(Object data) {
            System.out.println("Node.setData");
            this.data = data;
        }
    }


    /**
     * 类型擦除后，方法签名不匹配。
     * Node方法变成了setData(Object)，MyNode方法变成了setData(Integer)。
     * 因此，MyNode setData方法不会覆盖Node setData方法。
     * <p>
     * 为了解决这个问题，并在类型擦除后保留通用类型的多态性，
     * Java编译器生成了一个桥接方法，以确保子类型的工作符合预期。
     * 对于MyNode类，编译器为setData生成了以下桥接方法。
     */
    public static class MyNode extends Node {
        public MyNode(Integer data) {
            super(data);
        }

        /**
         * Bridge method generated by the compiler
         * 可以看到，类型擦除后的桥接方法，与Node类的setData方法具有相同的方法签名，
         * 委托给了原来的setData方法。
         */
        public void setData(Object data) {
            setData((Integer) data);
        }

        public void setData(Integer data) {
            System.out.println("MyNode.setData");
            super.setData(data);
        }
    }


}
