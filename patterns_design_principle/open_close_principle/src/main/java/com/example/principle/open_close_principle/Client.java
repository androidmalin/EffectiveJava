package com.example.principle.open_close_principle;

/**
 * 开闭原则（Open-ClosedPrinciple，OCP)
 * <p>
 * 指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
 * <p>
 * 所谓开闭，也正是对扩展和修改两个行为的一个原则。
 * <p>
 * 强调的是用抽象构建框架，用实现扩展细节，可以提高软件系统的可复用性及可维护性。
 * <p>
 * 开闭原则是面向对象设计中最基础的设计原则。
 * <p>
 * 它指导我们如何建立稳定灵活的系统，例如版本更新，我们尽可能不修改源码，但是可以增加新功能。
 * <p>
 * <p>
 * 在现实生活中，开闭原则也有体现。
 * 比如，很多互联网公司都实行弹性制作自时间，规定每天工作8小时。
 * <p>
 * 意思就是，对于每天工作8小时这个规定是关闭的，但是什么时候来、什么时候走是开放的。
 * 早来早走，晚来晚走。
 * <p>
 * <p>
 * 实现开闭原则的核心思想就是面向抽象编程。
 * <p>
 * <p>
 * 抽象化是关键
 * <p>
 * 解决问题的关键在于抽象化。
 * 在像java这样的面向对象编程语言里面，可以给系统一个一劳永逸、不再改变的抽象设计，该设计允许有无穷无尽的行为在实现层被实现。
 * 在java语言里，可以给出一个或多个抽象java类或者java接口，规定出所有的具体类必须提供的方法的特征作为系统设计的抽象层。
 * 这个抽象层预见了所有的可能扩展，因此，在任何情况下都不会改变。
 * 这使得系统的抽象层不需要修改，从而满足了"开-闭"原则的第二条:对修改关闭。
 * <p>
 * 同时，由于从抽象层导出的一个或多个新的具体类可以改变系统的行为，因此系统的设计对扩展是开放的，这就满足了"开-闭"原则的第一条:对扩展开放。
 * <p>
 * 对可变性的封装
 * 考虑你的设计中有什么可能会发生变化。
 * 这一思想用一句话总结为:"找到一个系统的可变因素，将它封装起来"。
 * <p>
 * 这意味着两点:
 * 1、一种可变性不应该散落在代码的很多角落里，而应该被封装到一个对象里面。同一种可变性的不同表象意味着同一个继承等级结构中的具体子类。
 * 2、一种可变性不应该与另一种可变性混合在一起。
 */
public class Client {

    public static void main(String[] args) {
        JavaDiscountCourse discountCourse = new JavaDiscountCourse(1, "Java架构", 11800D);
        System.out.println("课程ID:" + discountCourse.getId() +
                "\n课程标题:《" + discountCourse.getName() + "》" +
                "\n原价:" + discountCourse.getPrice() +
                "\n售价:" + discountCourse.getDiscountPrice());
    }

}
